#!/usr/bin/python3

#
#  The update for this program can be found at https://github.com/alanshlam/Pentest/tree/main/suricata
#
# This program monitors SID 1000001 in the fast.log and runs in daemon mode.
#
# When an alert with SID 1000001 is detected, this program will send 
# an alert mail with scan data in CSV formation.
#
# This program also takes care of continuing to monitor the fast.log after log rotation.
#

import os
import smtplib
import json
import time
import csv
import io
import socket
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
import daemon
import lockfile
from datetime import datetime, timezone
import pytz

def parse_alert(line):
    if '1000001' in line:
        parts = line.split('  ')
        timestamp_str = parts[0].strip()
        alert_details = parts[1].strip().split(' ')
        src_ip, src_port = alert_details[-3].split(':')
        dst_ip, dst_port = alert_details[-1].split(':')
        return {
            'timestamp': timestamp_str,
            'src_ip': src_ip,
            'src_port': src_port,
            'dst_ip': dst_ip,
            'dst_port': dst_port
        }
    return None

def extract_flow_data(src_ip, alert_timestamp):
    flow_data = []
    alert_time = datetime.strptime(alert_timestamp, "%m/%d/%Y-%H:%M:%S.%f")
    local_tz = pytz.timezone('Asia/Shanghai')  # +08:00 timezone
    alert_time = local_tz.localize(alert_time)
    alert_unix_time = alert_time.timestamp()  # Convert to Unix time

    with open('/var/log/suricata/eve.json', 'r') as f:
        for line in f:
            try:
                log_entry = json.loads(line)
                log_timestamp = datetime.strptime(log_entry.get('timestamp'), "%Y-%m-%dT%H:%M:%S.%f%z")

                # Convert log_timestamp to the same timezone as alert_time
                log_timestamp = log_timestamp.astimezone(local_tz)
                log_unix_time = log_timestamp.timestamp()  # Convert to Unix time

                # Debugging output
                # print(f"Comparing log_unix_time: {log_unix_time} with alert_unix_time: {alert_unix_time}")

                if log_entry.get('event_type') == 'flow':
                    if log_unix_time >= alert_unix_time:
                        if log_entry.get('src_ip') == src_ip:
                            flow_data.append([
                                log_entry.get('timestamp'),
                                log_entry.get('src_ip'),
                                log_entry.get('src_port'),
                                log_entry.get('dest_ip'),
                                log_entry.get('dest_port')
                            ])
            except json.JSONDecodeError as e:
                # print(f"Error decoding JSON: {e}")
                pass
            except KeyError as e:
                # print(f"KeyError: {e} in log entry: {log_entry}")
                pass
    return flow_data

def send_email(alert, flow_data):
    # DNS lookup for the source IP
    try:
        hostname = socket.gethostbyaddr(alert['src_ip'])[0]
    except socket.herror:
        hostname = "Unknown"

    msg = MIMEMultipart()
    msg['From'] = 'your-email@example.com'
    msg['To'] = 'recipient@example.com'
    msg['Subject'] = f"Suricata Alert Detected - {alert['src_ip']} ({hostname})"

    message = (f"Alert detected:\n\nTimestamp: {alert['timestamp']}\n"
               f"Source IP: {alert['src_ip']} ({hostname})\nSource Port: {alert['src_port']}\n"
               f"Destination IP: {alert['dst_ip']}\nDestination Port: {alert['dst_port']}\n")

    if not flow_data:
        message += "\nNo matching flow data found."
    else:
        message += "\nFlow data matching the alert has been found and attached."

    msg.attach(MIMEText(message))

    if flow_data:
        # Convert flow data to CSV
        csv_buffer = io.StringIO()
        csv_writer = csv.writer(csv_buffer)
        csv_writer.writerow(['Timestamp', 'Source IP', 'Source Port', 'Destination IP', 'Destination Port'])
        csv_writer.writerows(flow_data)
        csv_content = csv_buffer.getvalue()
        csv_buffer.close()

        # Create a filename with the src_ip and the first timestamp
        first_timestamp = flow_data[0][0].replace(':', '-')
        filename = f"flow_data_{alert['src_ip']}_{first_timestamp}.csv"

        part = MIMEBase('application', 'octet-stream')
        part.set_payload(csv_content.encode())
        encoders.encode_base64(part)
        part.add_header('Content-Disposition', f'attachment; filename="{filename}"')
        msg.attach(part)

    with smtplib.SMTP('mx.example.com', 25) as mailserver:
        mailserver.sendmail('your-email@example.com', 'recipient@example.com', msg.as_string())

def follow(file_path):
    with open(file_path, 'r') as file:
        file.seek(0, os.SEEK_END)
        while True:
            line = file.readline()
            if not line:
                time.sleep(1)
                continue
            yield line

def get_inode(file_path):
    return os.stat(file_path).st_ino

def monitor_log():
    log_file_path = '/var/log/suricata/fast.log'
    current_inode = get_inode(log_file_path)

    while True:
        loglines = follow(log_file_path)
        for line in loglines:
            alert = parse_alert(line)
            if alert:
                # print(f"Processing alert: {alert}")  # Debugging output for alert
                time.sleep(60)  # Sleep for 60 seconds before extracting flow data
                flow_data = extract_flow_data(alert['src_ip'], alert['timestamp'])
                send_email(alert, flow_data)
            if get_inode(log_file_path) != current_inode:
                current_inode = get_inode(log_file_path)
                break

def run_as_daemon():
    with daemon.DaemonContext(
        working_directory='/',
        umask=0o002,
        pidfile=lockfile.FileLock('/var/run/send_alert_sample.pid')
    ):
        monitor_log()

if __name__ == "__main__":
    run_as_daemon()

